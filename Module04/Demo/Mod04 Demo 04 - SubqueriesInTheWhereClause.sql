-- MODULE 4 DEMO 4: Subqueries in the WHERE clause

USE AdventureWorks

/* 
Because WHERE clauses usually process comparison
operations, a subquery in a where clause will 
usually participate in that comparisson.

1. Scalar Subqueries

The following query compares the ListPrice, which
is a scalar value, to the results of a scalar
subquery (a query that returns one row and one
column). Before you run this query, highlight just
the subquery and run it to see the scalar value 
that it generates. */

SELECT Name
, ListPrice
FROM Production.Product 
WHERE listprice > (SELECT AVG(ListPrice) 
                   FROM Production.Product) 

/* 
2. Subqueries with the IN Operator

The query below uses the IN operator to compare the
ProductSubCategoryID on a row to a list of 
product subcategory ids generated by a subquery. Since
the IN operator works with lists, the subquery must
output only one column. Before you run this query,
highlight just the subquery and run it to see the list
of values it generates. Do you see why it's important
to include only one column in this subquery? If there 
were more columns, SQL Server would not be able to 
generate a list! */

SELECT Name ProductName
FROM Production.Product 
WHERE ProductSubcategoryID IN (SELECT ProductSubcategoryID 
	                           FROM Production.ProductSubcategory 
	                           WHERE Name LIKE '%Bike%') 

/* Many subqueries in a WHERE clause, including those that
use the IN operator, can usually be written as joins 
without any gain or loss in performance. The following 
query is equivalent to the one above. */

SELECT p.Name ProductName
FROM Production.Product p
JOIN Production.ProductSubcategory sc
	ON p.ProductSubcategoryID = sc.ProductSubcategoryID
WHERE sc.Name LIKE '%Bike%'

/*
3. Correlated Subqueries

All of the subqueries shown so far can be run independently
of the outer queris they arein. If you highlight just the 
subquery and execute it, it will run. You can't do that
with a correlated subquery, because correlated subqueries
depend on a value provided by the outer query. 

In the query below, the subquery references e.EmployeeID. 
"e" is an alias that is defined in the outer query. In a 
correlated subquery, the subquery runs for each row of the 
outer query. 

Before you run the query, highlight just the subquery and
try to run it. Notice that it fails. */

SELECT DISTINCT e.EmployeeID 
, c.LastName
, c.FirstName
FROM Person.Contact c 
INNER JOIN HumanResources.Employee e
    ON e.ContactID = c.ContactID
WHERE 5000.00 < (SELECT Bonus
				 FROM Sales.SalesPerson sp
				 WHERE sp.SalesPersonID = e.EmployeeID) 

/*
4. The EXISTS operator

In the following correlated subquery, the WHERE clause
evaluates to True only if at least one row is returned by
the subquery. The EXISTS operator doesn't care what is 
returned, but only THAT something is returned. Because of 
that, the * can be used without the usual degredation in
performance associated with it. */

SELECT Name
FROM Production.Product p
WHERE EXISTS
    (SELECT * 
     FROM Production.ProductSubcategory
     WHERE ProductSubcategoryID = p.ProductSubcategoryID
       AND Name = 'Wheels')

